% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_interface.R
\name{fit_ability}
\alias{fit_ability}
\title{Fit IRT Model for Ability Scoring}
\usage{
fit_ability(
  response_data,
  item_loadings,
  threshold_left,
  threshold_right,
  person_covariates = NULL,
  weights = NULL,
  method = c("map", "laplace", "vb", "mcmc", "optim", "nloptr"),
  ...
)
}
\arguments{
\item{response_data}{Data frame with columns \code{pid} (person ID) and
\code{iid} (item ID). Person IDs should be consecutive integers from 1 to N.}

\item{item_loadings}{Matrix of factor loadings (L x K), where L is the number
of response observations and K is the number of dimensions.}

\item{threshold_left}{Numeric vector of left thresholds for each response (length L).
Use \code{-Inf} for left-unbounded categories.}

\item{threshold_right}{Numeric vector of right thresholds for each response (length L).
Use \code{Inf} for right-unbounded categories.}

\item{person_covariates}{Optional matrix of person-level covariates (N x J).
If NULL, an intercept-only model is used.}

\item{weights}{Optional vector of person weights (length N). If NULL, all
persons receive equal weight of 1.}

\item{method}{Estimation method to use:
\describe{
\item{"map"}{Maximum A Posteriori (fastest)}
\item{"laplace"}{Laplace approximation (MAP + uncertainty)}
\item{"vb"}{Variational Bayes}
\item{"mcmc"}{Full Bayesian MCMC (slowest, most accurate)}
\item{"optim"}{Base R optim() via BridgeStan (requires setup)}
\item{"nloptr"}{nloptr algorithms via BridgeStan (requires setup)}
}}

\item{...}{Additional arguments passed to the specific estimation function.
See \code{\link{fit_irt_map}}, \code{\link{fit_irt_laplace}},
\code{\link{fit_irt_vb}}, \code{\link{fit_irt_mcmc}},
\code{\link{fit_irt_optim}}, or \code{\link{fit_irt_nloptr}} for details.}
}
\value{
Object of class "irt_fit" containing:
\item{theta}{N x K matrix of estimated ability scores}
\item{beta0}{Length K vector of dimension intercepts}
\item{b}{K x J matrix of covariate effects}
\item{tau}{Length K vector of dimension standard deviations}
\item{Omega}{K x K correlation matrix}
\item{log_lik}{Log-likelihood value}
\item{method}{Estimation method used}
\item{backend}{Backend used (cmdstanr, rstan, or bridgestan)}
\item{stan_fit}{Original fit object}
}
\description{
Main interface for fitting unidimensional or multidimensional IRT models.
This function prepares data and routes to the appropriate estimation method.
}
\details{
This is the main user-facing function for fitting IRT models. It handles
data preparation and routes to the appropriate estimation method based on
the \code{method} argument.

\strong{Recommended methods:}
\itemize{
\item \code{"map"}: Fast point estimates, good for most applications
\item \code{"laplace"}: MAP plus uncertainty quantification
\item \code{"vb"}: Fast approximate Bayesian inference
\item \code{"mcmc"}: Complete posterior distributions, gold standard
}

\strong{Advanced methods} (require BridgeStan setup):
\itemize{
\item \code{"optim"}: Access to optim() algorithms
\item \code{"nloptr"}: Access to NLopt algorithms
}
}
\examples{
\dontrun{
# Unidimensional IRT with MAP estimation
response_data <- data.frame(
  pid = c(1, 1, 2, 2, 3, 3),
  iid = c(1, 2, 1, 2, 1, 2)
)
loadings <- matrix(c(1, 1.5, 1, 1.5, 2, 1.2), ncol = 1)
thresh_L <- c(-Inf, -1, -Inf, -1, -Inf, -2)
thresh_R <- c(-1, Inf, -1, Inf, -2, Inf)

fit <- fit_ability(
  response_data = response_data,
  item_loadings = loadings,
  threshold_left = thresh_L,
  threshold_right = thresh_R,
  method = "map"
)

# Multidimensional IRT with MCMC
loadings_2d <- matrix(c(1, 0.5, 1, 0.5, 0.5, 1), ncol = 2)
fit_mcmc <- fit_ability(
  response_data = response_data,
  item_loadings = loadings_2d,
  threshold_left = thresh_L,
  threshold_right = thresh_R,
  method = "mcmc",
  chains = 4,
  iter = 2000
)
}

}
